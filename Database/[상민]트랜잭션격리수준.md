## CS스터디: DB 트랜잭션 격리수준

트랜잭션 격리수준(isolation level)이란, 동시에 여러 트랜잭션이 처리가 될 때 트랜잭션끼리 얼마나 서로 고립이 되어있는지를 나타내는 것이다. 쉽게 얘기하면, 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준을 의미한다.

데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 하고, 그래서 Locking(트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것)이라는 개념이 등장한다.

그러나 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능이 떨어지게 된다. 반대로 응답성을 높이기 위해 Locking의 범위를 줄인다면 잘못된 값이 처리될 여지가 있다. 그래서 효율적인 Locking이 필요하다.

크게 네 가지로 나뉜다.

1. READ UNCOMITTED
2. READ COMITTED
3. REPEATABLE READ
4. SERIALIZABLE

1번에서 4번으로 갈수록 비용이 높아지며, 성능이 떨어지는 것이 일반적이다. 대부분의 서비스에서는 2번이나 3번 중 하나를 사용한다.
(대표적인 예시로 오라클이 2번, MySQL이 3번을 사용함)

### 1. READ UNCOMITTED

- 각 트랜잭션에서의 변경 내용이 `COMMIT`이나 `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 값을 읽을 수 있는 상태
- 정합성에 문제가 많은 격리수준이므로 사용을 권장하지 않음
- `Commit`이 되지 않는 상태지만 `Update`된 값을 다른 트랜잭션에서 읽을 수 있음

<img width="893" alt="스크린샷 2021-08-08 오전 10 09 43" src="https://user-images.githubusercontent.com/61453718/128617581-1d3ad999-befa-459d-9627-b8e2b5289195.png">

- `DIRTY READ`(트랜잭션 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상) 현상이 발생한다는 문제가 있다.

### 2. READ COMITTED

- RDB에서 기본적으로 사용되고 있는 격리 수준
- 위에서 말한 `DIRTY READ`같은 현상이 발생하지 않음

<img width="887" alt="스크린샷 2021-08-08 오전 10 13 18" src="https://user-images.githubusercontent.com/61453718/128617612-b383c9ff-8d82-447e-8db5-56338d816745.png">

- 실제 테이블 값을 가져오는 것이 아니라 `Undo` 영역에 백업된 레코드에서 값을 가져옴

<img width="735" alt="스크린샷 2021-08-08 오전 10 13 59" src="https://user-images.githubusercontent.com/61453718/128617625-e993e350-75d1-491c-86dd-e44f05a0e5be.png">

- 그렇지만 이러한 READ COMMITED 또한 아래와 같은 문제가 있음:
- `트랜잭션-1`이 Commit한 이후 아직 끝나지 않는 `트랜잭션-2`가 다시 테이블 값을 읽으면 값이 변경됨을 알 수 있음
- 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋남
- 보통 주로 입금, 출금 처리가 진행되는 금전적인 처리에서 이러한 문제가 발생함
  - 데이터의 정합성은 깨지고 버그는 찾기 어려워짐

### 3. REPEATABLE READ

- MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 됨
- `Undo` 공간에 백업해두고 실제 레코드 값을 변경함
  - 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제함
  - Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있음
- 이러한 변경 방식을 MVCC(Multi Version Concurrency Control)라고 부름

<img width="759" alt="스크린샷 2021-08-08 오전 10 19 06" src="https://user-images.githubusercontent.com/61453718/128617717-d51cc077-6c11-41ea-9d88-9b7b188505f9.png">

- `PHANTOM READ`라는 문제가 발생
  - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보이거나, 안보였다가 보이는 현상이 발생
  - 한 트랜잭션이 수행중일 때 다른 트랜잭션이 새로운 레코드를 삽입할 때 나타남
  - 이를 방지하기 위해 쓰기 잠금을 걸어야 함

### 4. SERIALIZABLE

- 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준임
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 레벨
- 완벽한 읽기 일관성 모드를 제공하여, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능함
- 성능 측면에서는 동시 처리성능이 가장 낮음
- `SERIALIZABlE`에서는 `PHANTOM READ`가 발생하지 않지만, DB에서 거의 사용되지 않음
